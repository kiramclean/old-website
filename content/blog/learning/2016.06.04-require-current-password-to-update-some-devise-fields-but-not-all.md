+++
date = "2016-06-03T12:57:26-04:00"
draft = true
title = "require current password to update some devise fields but not all"
+++

Devise is a great solution for setting up robust and flexible authentication in your Rails app quickly. It works great out of the box, but it can be slightly mystifying to add custom functionality, despite [Devise's awesome wiki](https://github.com/plataformatec/devise/wiki). For an app with users a feature you're going to need is allowing users to update their profile information and account credentials. Devise comes with a simple form to allow users to update their email and password, but what if you want to add custom fields to your `User` model? Your users are going to need to be able to update those, too. And that brings me to the main point of this post: when should a user have to enter their current password to update their profile? The norm on most websites is that you have to enter your current password if you're changing your password, but not if you're changing your name or other profile info. I think this makes sense. It depends what attributes your users have, but in most cases I think making them enter their password to update is overkill and leads to a bad user experience. For security reasons it's still good to require that users enter their current password in order to update their password, though. Right now there's no baked-in way to get this funtionality out of devise. After a little messing around I got it working, so I'll share here.

## Adding Custom Attributes to Devise Users

Before you can allow your users to update custom profile attributes, you have to add them to your `User` model. Adding attributes to a Devise model is the same as adding attributes to any other model. I want my users to have a name and twitter handle, so I'll go through adding those fields and allowing users to edit them without requiring their current password from start to finish, while still requiring users to enter their current password to update their password.

First, generate the migration:

```bash
rails g migration add_name_and_twitter_handle_to_users name twitter
```

This gives you:

```ruby
class AddNameAndTwitterHandleToUsers < ActiveRecord::Migration
  def change
    add_column :users, :name, :string
    add_column :users, :twitter, :string
  end
end
```

Looks good. Go ahead and run `rake db:migrate` to add those fields to your users.

## Allowing Users to Edit Custom Attributes

Now that your users can have a name and a twitter handle, they need a way to add or edit them. By default your users won't be able to update these fields because of the way Devise handles strong parameters. To allow these fields past the strong parameter filters, you need to create a custom `RegistrationsController` that inherits from `Devise::RegistrationsController`. In that controller you can specify which params you want to let through by calling Devise's `devise_paramater_sanitizer`. This gives you a `RegistrationsController` that looks like this:

```ruby
class RegistrationsController < Devise::RegistrationsController
  def update
    configure_strong_params
    super
  end

  private

    def configure_permitted_parameters
      devise_parameter_sanitizer.for(:account_update) do |user|
        user.permit(:email,
                    :name,
                    :password,
                    :password_confirmation,
                    :current_password)
      end
    end
```

You also need to tell devise to use your controller and not it's own in `routes.rb`:

```ruby
devise_for :users, controllers: { registrations: 'registrations' }
```

I added these params `.for(:account_update)` but you might want to so the same thing `.for(:sign_up)` if you have custom fields in your app's sign-up (`devise/registrations#create`) form. Now your users will be able to edit your custom fields. If you try it out right now, though, you'll notice the `current_password` is still required. You'll get a "Current password is invalid" error.

## Don't Require `current_password`

Devise provides an `update_without_password` method, but [if you implement it the way they recommend](https://github.com/plataformatec/devise/wiki/How-To:-Allow-users-to-edit-their-account-without-providing-a-password) it will allow users to update any attribute without inputting their current password. To allow users to update their info without a password, but still require their current password if they want to update their login credentials, you can do this:

```ruby
# in registrations_controller.rb

private

  def update_resource(resource, update_params)
    if user_changing_password?
      super
    else
      resource.update_without_password(update_params)
    end
  end

  def user_changing_password?
    !params[:password].blank?
  end
```

It sort of looks like it comes out of nowhere which sucks, but if you check out the `Devise::RegistrationsController`, you'll see where `update_resource` is called, and that `resource` and `update_params` are available. You can open any gem to check it out by running `bundle open name-of-the-gem`. With this, your users will be required to put in their current password to change it, but they won't be asked if they're changing any other attribute.

## What about testing?

Even if you don't religiously maintain 100% test coverage, you'll want all the authentication logic in your app to be fully tested. This is how I went about it, to give you an idea of how to get started. The `login_as` helper comes from `Warden::Test::Helpers` and I'm using [Factory Girl](https://github.com/thoughtbot/factory_girl) to `create` users for testing.

```ruby
# spec/controllers/registrations_controller_spec.rb

describe 'PUT #update' do
  context 'updating only name and/or email' do
    it 'allows updating non-devise attributes without requiring current_password' do
      user = create :user, name: 'A Name'
      login_as user

      put :update, user: { fullname: 'Test Owner' }

      expect(assigns[:user].errors).to be_empty
      expect(assigns[:user].fullname).to eq 'Test Owner'
      expect(flash[:notice]).to eq 'Your account has been updated successfully.'
    end

    it 'updates the email without requiring current_password' do
      user = create :user
      sign_in user

      put :update, user: { email: 'testemail@test.com' }

      expect(assigns[:user].errors).to be_empty
      expect(assigns[:user].email).to eq 'testemail@test.com'
      expect(flash[:notice]).to eq 'Your account has been updated successfully.'
    end
  end

  context 'updating password' do
    before do
      user = create :user, password: 'the_right_password'
      sign_in user
    end

    context 'with valid attributes' do
      it 'redirects to the right place' do
        put :update, user: { password: 'asdfasdf',
                              password_confirmation: 'asdfasdf',
                              current_password: 'the_right_password' }

        expect(flash[:notice]).to eq 'Your account has been updated successfully.'
        expect(response).to redirect_to users_settings_path
      end
    end

    context 'with invalid or insufficient attributes' do
      it 'requires current password to update password' do
        put :update, user: { password: 'asdfasdf',
                              password_confirmation: 'asdfasdf' }

        expect(assigns[:user].errors.messages).to eq current_password: ["can't be blank"]
        expect(flash[:alert]).to eq "Current password can't be blank"
        expect(response).to render_template :edit
      end

      it 'does not accept the wrong current_password' do
        put :update, user: { password: 'asdfasdf',
                              password_confirmation: 'asdfasdf',
                              current_password: 'not_the_same_password' }

        expect(assigns[:user].errors.messages).to eq current_password: ["is invalid"]
        expect(flash[:alert]).to eq "Current password is invalid"
        expect(response).to render_template :edit
      end

      it 'does not accept mis-matched passwords' do
        put :update, user: { password: 'asdfasdf',
                              password_confirmation: 'a_different_password',
                              current_password: 'the_right_password' }

        expect(assigns[:user].errors.messages).to eq password_confirmation: ["doesn't match Password"]
        expect(flash[:alert]).to eq "Password confirmation doesn't match Password"
        expect(response).to render_template :edit
      end
    end
  end
end
```




    = form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f|
      .mdl-card.mdl-shadow--2dp.mdl-card--expand
        .mdl-card__title.mdl-card--border
          .mdl-card__title-text = t('settings.account.change.title')
        .mdl-card__supporting-text

          .mdl-textfield.mdl-js-textfield.mdl-textfield--floating-label.mdl-textfield--full-width
            = f.text_field :fullname, class: 'mdl-textfield__input'
            = f.label :fullname, t('dictionary.name'), class: 'mdl-textfield__label'
            = f.error :fullname, class: 'error-msg'

          .mdl-textfield.mdl-js-textfield.mdl-textfield--floating-label.mdl-textfield--full-width
            = f.email_field :email, autofocus: true, class: 'mdl-textfield__input'
            = f.label :email, t('dictionary.email'), class: 'mdl-textfield__label'
            = f.error :email, class: 'error-msg'

          .form-actions
            = f.submit t('dictionary.save'), class: 'mdl-button mdl-button--raised mdl-button--primary mdl-js-button mdl-js-ripple-effect', data: { disable_with: t('dictionary.saving') }

    = form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f|
      .mdl-card.mdl-shadow--2dp.mdl-card--expand
        .mdl-card__title.mdl-card--border
          .mdl-card__title-text = t('password.change.title')
        .mdl-card__supporting-text

          .mdl-textfield.mdl-js-textfield.mdl-textfield--floating-label.mdl-textfield--full-width
            = f.password_field :current_password, autocomplete: "off", class: 'mdl-textfield__input'
            = f.label :current_password, t('password.change.current'), class: 'mdl-textfield__label'
            = f.error :current_password, class: 'error-msg'

          .mdl-textfield.mdl-js-textfield.mdl-textfield--floating-label.mdl-textfield--full-width
            = f.password_field :password, autocomplete: "off", class: 'mdl-textfield__input'
            = f.label :password, t('password.change.new'), class: 'mdl-textfield__label'
            = f.error :password, class: 'error-msg'

          .mdl-textfield.mdl-js-textfield.mdl-textfield--floating-label.mdl-textfield--full-width
            = f.password_field :password_confirmation, autocomplete: "off", class: 'mdl-textfield__input'
            = f.label :password_confirmation, t('password.change.confirm'), class: 'mdl-textfield__label'
            = f.error :password_confirmation, class: 'error-msg'

          .form-actions
            = f.submit t('dictionary.save'), class: 'mdl-button mdl-button--raised mdl-button--primary mdl-js-button mdl-js-ripple-effect', data: { disable_with: t('dictionary.saving') }



*** Implement this on a fresh rails app to try it out -- probably need to set the flash as well in update
